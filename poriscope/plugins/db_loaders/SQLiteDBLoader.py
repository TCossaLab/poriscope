# MIT License
#
# Copyright (c) 2025 TCossaLab
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Contributors:
# Kyle Briggs

import contextlib
import logging
import sqlite3
from pathlib import Path
from typing import Generator, List, Optional, Tuple, cast

import numpy as np
import numpy.typing as npt
import pandas as pd
from typing_extensions import override

from poriscope.utils.DocstringDecorator import inherit_docstrings
from poriscope.utils.LogDecorator import log
from poriscope.utils.MetaDatabaseLoader import MetaDatabaseLoader


@inherit_docstrings
class SQLiteDBLoader(MetaDatabaseLoader):
    """
    Subclass of MetaDatabaseLoader for reading and querying SQLite database files.

    Provides functionality to load metadata, event data, and other relevant
    structures from a structured SQLite database generated by Poriscope.
    """

    logger = logging.getLogger(__name__)

    # public API, MUST be implemented by subclasses
    @log(logger=logger)
    @override
    def get_llm_prompt(self):
        """
        Return a prompt that will tell the LLM the structure of the database to be queried

        :return: a prompt that gives an LLM context for the database and  how to query it
        :rtype: str
        """
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            metadata = ""

            # 1. List all tables in the database
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
            tables = cursor.fetchall()
            metadata += "Tables:\n" + "\n".join([table[0] for table in tables]) + "\n\n"

            # 2. List all columns in each table
            for table in tables:
                table_name = table[0]
                cursor.execute(f"PRAGMA table_info({table_name});")
                columns = cursor.fetchall()
                metadata += f"Columns in {table_name}:\n"
                for column in columns:
                    metadata += f"  - {column[1]} (Type: {column[2]}, Not Null: {column[3]}, Default: {column[4]})\n"
                metadata += "\n"

            # 3. List all indices in the database
            cursor.execute("SELECT name FROM sqlite_master WHERE type='index';")
            indices = cursor.fetchall()
            metadata += (
                "Indices:\n" + "\n".join([index[0] for index in indices]) + "\n\n"
            )

            # 4. List all triggers in the database
            cursor.execute("SELECT name FROM sqlite_master WHERE type='trigger';")
            triggers = cursor.fetchall()
            metadata += (
                "Triggers:\n" + "\n".join([trigger[0] for trigger in triggers]) + "\n\n"
            )

            # 5. List all foreign key constraints
            for table in tables:
                table_name = table[0]
                cursor.execute(f"PRAGMA foreign_key_list({table_name});")
                foreign_keys = cursor.fetchall()
                if foreign_keys:
                    metadata += f"Foreign Keys in {table_name}:\n"
                    for fk in foreign_keys:
                        metadata += f"  - {fk[3]} -> {fk[4]} (on {fk[2]})\n"
                    metadata += "\n"

            # 6. Schema of the database (full dump)
            cursor.execute("SELECT sql FROM sqlite_master WHERE type='table';")
            schema = cursor.fetchall()
            metadata += "Schema:\n" + "\n".join([s[0] for s in schema]) + "\n\n"

            # Close the connection
            return metadata
        except sqlite3.Error as e:
            self.logger.error(
                f"Database error getting channels available for experiment: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def close_resources(self, channel: Optional[int] = None) -> None:
        """
        Close resources gracefully before application exit.

        :param channel: Channel ID to close. If None, close all resources.
        :type channel: Optional[int]
        """
        # database connection is not persistent between calls so no action needed on final closing
        pass

    @log(logger=logger)
    @override
    def reset_channel(self, channel=None):
        """
        Perform any actions necessary to reset a channel to its starting state. If channel is not None, handle only that channel, else reset all of them.

        :param channel: channel ID
        :type channel: int
        """
        # database connection is not persistent between calls so no action needed here closing
        pass

    @log(logger=logger)
    @override
    def get_experiment_names(
        self, experiment_id: Optional[int] = None
    ) -> Optional[List[str]]:
        """
        Retrieve a list of all unique experiment names registered in the database or a singleton list if a name is given.

        :param experiment_id: the id of the experiment for which to fetch the name
        :type experiment_id: Optional[int]

        :return: List of experiment names, or None on failure
        :rtype: Optional[List[str]]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                if experiment_id is None:
                    query = "SELECT name FROM experiments;"
                    cursor.execute(query)
                    experiment_names = [row[0] for row in cursor.fetchall()]
                    self.logger.debug(
                        f"All experiment names fetched: {experiment_names}"
                    )
                    return list(set(experiment_names)) if experiment_names else None
                else:
                    query = "SELECT name FROM experiments WHERE id=?;"
                    cursor.execute(query, (experiment_id,))
                    experiment_name = cursor.fetchone()
                    self.logger.debug(
                        f"Experiment name for id {experiment_id}: {experiment_name}"
                    )
                    return [experiment_name[0]] if experiment_name else None
        except sqlite3.Error as e:
            self.logger.error(f"Database error fetching experiment names: {e}")
            return None

    @log(logger=logger)
    @override
    def get_channels_by_experiment(self, experiment: str) -> Optional[List[int]]:
        """
        Retrieve a list of all channel IDs associated with a given experiment name or None on failure

        :param experiment: The name of the experiment.
        :type experiment: str
        :return: List of channel IDs.
        :rtype: Optional[List[int]]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = """
                    SELECT channels.channel_id
                    FROM channels
                    JOIN experiments ON channels.experiment_id = experiments.id
                    WHERE experiments.name = ?;
                    """
                    cursor.execute(query, (experiment,))
                    channels = cursor.fetchall()
                    if channels:
                        return [int(channel[0]) for channel in channels]
                    else:
                        return None
        except sqlite3.Error as e:
            self.logger.error(
                f"Database error getting channels available for experiment {experiment}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_event_counts_by_experiment_and_channel(self, experiment=None, channel=None):
        """
        Return the number of events in the database matching the experiment name and channel name.
        If no channel name is provided, count across all channels for that experiment.
        If no experiment is provided, ignore channel and return the number of events in the entire database

        :param experiment: The name of the experiment.
        :type experiment: Optional[str]
        :param channel: The index of the channel
        :type channel: Optional[int]

        :return: event count matching the conditions
        :rtype: int
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    if experiment is None:
                        query = """
                        SELECT COUNT(*)
                        FROM events
                        """
                    elif experiment is not None and channel is None:
                        query = """
                                SELECT COUNT(*)
                                FROM events
                                JOIN experiments ON events.experiment_id = experiments.id
                                WHERE experiments.name = ?;
                                """
                    elif experiment is not None and channel is not None:
                        query = """
                                SELECT COUNT(*)
                                FROM events
                                JOIN experiments ON events.experiment_id = experiments.id
                                WHERE experiments.name = ?
                                AND events.channel_id = ?;
                                """

                    cursor.execute(query, (experiment, channel))
                    num_events = cursor.fetchone()
                    if num_events:
                        return num_events[0]
                    else:
                        return 0
        except sqlite3.Error as e:
            self.logger.error(
                f"Database error getting event counts for experiment {experiment} and channel {channel}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_column_units(self, column_name: str) -> Optional[str]:
        """
        Retrieve the units associated with a specific column name, or None on failure

        :param column_name: The name of the column.
        :type column_name: str
        :return: The units of the column, empty string is units is NULL
        :rtype: Optional[str]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = """
                    SELECT units
                    FROM columns
                    WHERE name = ?;
                    """
                    cursor.execute(query, (column_name,))
                    result = cursor.fetchone()
                    if result and result[0] is not None:
                        return result[0]
                    else:
                        return ""
        except sqlite3.Error as e:
            self.logger.error(
                f"Database error getting units for column {column_name}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_column_names_by_table(
        self, table: Optional[str] = None
    ) -> Optional[List[str]]:
        """
        Retrieve the column names available in a specified table.

        :param table: The name of the table.
        :type table: Optional[str]
        :return: List of column names.
        :rtype: Optional[List[str]]
        """
        query_stub = ""
        if table is not None:
            query_stub = f"""WHERE table_name='{table}'"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = f"""SELECT name FROM columns {query_stub};"""
                    cursor.execute(query)
                    result = cursor.fetchall()
                    if result:
                        return [column[0] for column in result]
                    else:
                        return None
        except sqlite3.Error as e:
            self.logger.warning(
                f"Database error fetching columns for table {table}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_table_names(self) -> Optional[List[str]]:
        """
        Retrieve the names of available tables in the database.

        :return: List of table names.
        :rtype: Optional[List[str]]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = "SELECT name FROM sqlite_master WHERE type = 'table';"
                    cursor.execute(query)
                    result = cursor.fetchall()
                    if result:
                        return [
                            table[0]
                            for table in result
                            if table[0] != "sqlite_sequence"
                        ]
                    else:
                        return None
        except sqlite3.Error as e:
            self.logger.warning(
                f"Database error fetching table names from database: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_table_by_column(self, column: str) -> Optional[str]:
        """
        :param column: The name of the column.
        :type column: str

        :return: List of table names.
        :rtype: List[str]

        **Purpose:** Retrieve the names of the table in which the given column is found, or None on failure
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = "SELECT table_name FROM columns WHERE name = ?;"
                    cursor.execute(query, (column,))
                    result = cursor.fetchone()
                    if result:
                        return result[0]
                    else:
                        return None
        except sqlite3.Error as e:
            self.logger.warning(
                f"Database error fetching table corresponding to column {column}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def validate_filter_query(self, query: str) -> Tuple[bool, str]:
        """
        Validate a SQL filter query without executing it.

        :param query: The SQL query string.
        :type query: str
        :return: True if valid query, False otherwise, plus error message if invalid or emnpty string on success
        :rtype:  Tuple[bool, str]
        """
        explain_query = f"EXPLAIN QUERY PLAN {query}"
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    cursor.execute(explain_query)
                    result = (
                        cursor.fetchall()
                    )  # This will not run the query but provide the query plan
                    if not result:
                        return (
                            False,
                            "Invalid query\n\n{query}\n\n no useful debugging information provided",
                        )
                    return True, ""
        except sqlite3.Error as e:
            return False, f"Invalid query\n\n{query}\n\n{str(e)}"
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def alter_database(self, queries: List[str]) -> bool:
        """
        Run a given list of queries on the DB. There is no validation here, use it sparingly.

        :param queries: a list of queries to  run on the database
        :type queries: List[str]

        :return: True if the operation succeeded, False otherwise
        :rtype: bool
        """
        conn = None
        cursor = None
        success = False
        try:
            conn = sqlite3.connect(self.db_path)
            conn.execute("PRAGMA foreign_keys = ON;")
            cursor = conn.cursor()
            conn.execute("SAVEPOINT alter_database")

            for query in queries:
                cursor.execute(query)

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in alter_database: {e}")
            if conn:
                conn.rollback()
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in alter_database: {e}")
            if conn:
                conn.rollback()
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error in alter_database: {e}")
            if conn:
                conn.rollback()
            raise
        else:
            success = True
            if conn:
                conn.commit()
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
        return success

    @log(logger=logger)
    @override
    def add_columns_to_table(
        self, df: pd.DataFrame, units: List[Optional[str]], table_name: str
    ) -> bool:
        """
        Adds new columns from a pandas DataFrame to an existing SQLite table
        and populates them with data, matching on the 'id' column.

        :param df: A pandas DataFrame. Must contain an 'id' column corresponding to the primary key of the target table, and one or more additional columns to be added.
        :type df: pd.DataFrame
        :param units: A list of strings specifying units for the new columns to be added. Must have length equal to the number of new cols, but can contain None values
        :type units: List[Optional[str]]
        :param table_name: The name of the SQLite table to modify. This table must already exist in the databse.
        :type table_name: str

        :return: True on success, False otherwise
        :rtype: bool

        :raises ValueError: If the DataFrame does not contain an 'id' column or if the specified table does not exist.
        :raises IOError: If any write-related error occurs
        """

        if "id" not in df.columns:
            self.logger.error("DataFrame must contain an 'id' column. No action taken.")
            return False

        new_cols = [col for col in df.columns if col != "id"]
        if not new_cols:
            self.logger.error(
                "DataFrame has no new columns (only 'id'). No action taken."
            )
            return False

        conn = None
        cursor = None
        success = False
        try:
            conn = sqlite3.connect(self.db_path)
            conn.execute("PRAGMA foreign_keys = ON;")
            cursor = conn.cursor()
            conn.execute("SAVEPOINT write_new_columns")

            cursor.execute(
                "SELECT name FROM sqlite_master WHERE type='table' AND name=?;",
                (table_name,),
            )
            if not cursor.fetchone():
                raise ValueError(
                    f"Table '{table_name}' does not exist in the database."
                )

            cursor.execute(f"PRAGMA table_info({table_name});")
            existing_cols = [row[1] for row in cursor.fetchall()]

            conflicting_cols = [col for col in new_cols if col in existing_cols]
            if conflicting_cols:
                raise ValueError(
                    f"Operation failed: The following columns already exist in table '{table_name}': {', '.join(conflicting_cols)}"
                )

            for col, unit in zip(new_cols, units):
                if unit is None:
                    unit = " "
                dtype = df[col].dtype
                sql_type = self._get_sqlite_type(dtype)
                cursor.execute(f"ALTER TABLE {table_name} ADD COLUMN {col} {sql_type};")
                try:
                    cursor.execute(
                        "INSERT INTO columns (name, table_name, units) VALUES (?, ?, ?);",
                        (col, table_name, unit),
                    )  # Assuming no units info
                except sqlite3.IntegrityError:
                    raise ValueError(
                        f"Column '{col}' already exists in the 'columns' table."
                    )

            set_clause = ", ".join([f"{col} = ?" for col in new_cols])
            sql_update = f"UPDATE {table_name} SET {set_clause} WHERE id = ?"

            data_to_update = []
            for _, row in df.iterrows():
                values = [
                    row[col] if not pd.isna(row[col]) else None for col in new_cols
                ]
                values.append(row["id"])
                data_to_update.append(tuple(values))

            cursor.executemany(sql_update, data_to_update)

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in add_columns_to_table: {e}")
            if conn:
                conn.rollback()
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in add_columns_to_table: {e}")
            if conn:
                conn.rollback()
            raise
        except Exception as e:
            self.logger.error(
                f"Unexpected error in add_columns_to_table: {e}", exc_info=True
            )
            if conn:
                conn.rollback()
            raise
        else:
            success = True
            if conn:
                conn.commit()
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
        return success

    @log(logger=logger)
    @override
    def get_samplerate_by_experiment_and_channel(
        self, experiment: str, channel: int
    ) -> Optional[float]:
        """
        Retrieve the sampling rate for a given experiment and channel id

        :param experiment: The name of the experiment in the database.
        :type experiment: str
        :param channel: The channel id to get sampling rate for.
        :type channel: int
        :return: sampling rate for the specific expreiment-channel combination, or None on failure
        :rtype: Optional[float]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    query = """
                    SELECT ch.samplerate
                    FROM channels ch
                    JOIN experiments exp ON ch.experiment_id = exp.id
                    WHERE exp.name = ? AND ch.channel_id = ?;
                    """
                    cursor.execute(query, (experiment, channel))
                    result = cursor.fetchone()
                    if result:
                        return float(result[0])
                    else:
                        raise ValueError(
                            f"Unable to extract samplerate for experiment {experiment} and channel {channel}. Double check your values"
                        )
        except sqlite3.Error as e:
            self.logger.warning(
                f"Database error fetching sampling rate for channel {channel} for experiment {experiment}: {e}"
            )
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @log(logger=logger)
    @override
    def get_empty_settings(self, globally_available_plugins=None, standalone=False):
        """
        Get a dict populated with keys needed to initialize the filter if they are not set yet.
        This dict must have the following structure, but Min, Max, and Options can be skipped or explicitly set to None if they are not used.
        Value and Type are required. All values provided must be consistent with Type.

        .. code-block:: python

          settings = {'Parameter 1': {'Type': <int, float, str, bool>,
                                           'Value': <value> or None,
                                           'Options': [<option_1>, <option_2>, ... ] or None,
                                           'Min': <min_value> or None,
                                           'Max': <max_value> or None,
                                           'Units': <unit str> or None
                                          },
                          ...
                          }


        Several parameter keywords are reserved: these are

        'Input File'
        'Output File'
        'Folder'

        These must have Type str and will cause the GUI to generate widgets to allow selection of these elements when used

        :param globally_available_plugins: a dict containing all data plugins that exist to date, keyes by metaclass
        :type globally_available_plugins: Dict[str, List[str]]
        :return: the dict that must be filled in to initialize the filter
        :rtype: Dict[str, Dict[str, Any]]
        """
        settings = super().get_empty_settings(globally_available_plugins, standalone)
        settings["Input File"]["Options"] = [
            "SQLite3 Files (*.sqlite3)",
            "Database Files (*.db)",
            "SQLite Files (*.sqlite)",
        ]
        return settings

    # Public API continued, should implemented by subclasses, but has default behavior if it is not needed

    # private API, MUST be implemented by subclasses
    @log(logger=logger)
    @override
    def _init(self) -> None:
        """
        called at the start of base class initialization
        """
        pass

    @log(logger=logger)
    @override
    def _validate_settings(self, settings: dict) -> None:
        """
        Validate that the settings dict contains the correct information for use by the subclass.

        :param settings: Parameters for event detection.
        :type settings: dict
        :raises ValueError: If the settings dict does not contain the correct information.
        """
        if "Input File" not in settings.keys():
            raise ValueError("SQLiteDBLoader requires an Input File in settings")

    @log(logger=logger)
    @override
    def _load_metadata(self, query: str) -> Optional[pd.DataFrame]:
        """
        Load and return the data specified by a valid SQL query formatted as a pandas dataframe

        :param query: a valid SQL query, checked in the calling function for validity
        :type query: str

        :return: A dataframe containing the requested event data as columns or None on failure
        :rtype: Optional[pd.DataFrame]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute(query)
                result = cursor.fetchall()
                if result:
                    column_names = [
                        description[0] for description in cursor.description
                    ]
                    return pd.DataFrame(result, columns=column_names)
                else:
                    return None
        except sqlite3.Error as e:
            self.logger.warning(f"Database error executing query {query}: {e}")
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def _load_metadata_generator(
        self, query: str
    ) -> Generator[pd.DataFrame, None, None]:
        """
        Load and return the data specified by a valid SQL query formatted as a pandas dataframe
        Make sure you exhaust the generator, or else connections will remain open

        :param query: query to  run on the database
        :type query: str

        :return: A generator that feeds out onne row at a time in the form of a single-line dataframe
        :rtype: Generator[pd.DataFrame, None, None]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute(query)
                column_names = [description[0] for description in cursor.description]
                while True:
                    result = cursor.fetchone()
                    if result is None:
                        break
                    else:
                        yield pd.DataFrame([result], columns=column_names)
        except sqlite3.Error as e:
            self.logger.warning(f"Database error executing query {query}: {e}")
            return None
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def _load_event_data(self, query):
        """
        Load data and return a generator that gives a one-row dataframe corresponding one row returned by query
        Make sure you exhaust or explicitly abort the generator, or else connections will remain open
        You can assume that the query was generated by self.construct_event_data_query() and will have 10 colums:
        event_id, channel_id, experiment_id, data_format, baseline, stdev, padding_before, padding_after, samplerate, data
        where data is a bytes object to be interpreted using data_format

        :param query: a valid SQL query, checked in the calling function for validity
        :type query: str

        :return: a generator that returns primary database id, experiment_id, channel_id, event_id, samplerate, padding_before, padding_after, samplerate, and three numpy arrays with raw event data, filtered event data, and fitted event data
        :rtype: Generator[Dict[str,Union[int, int, int, int, float, int, int, npt.NDArray[np.float64], npt.NDArray[np.float64], npt.NDArray[np.float64]]], bool, None]
        """
        try:
            with sqlite3.connect(self.db_path) as conn:
                with contextlib.closing(conn.cursor()) as cursor:
                    cursor.execute(query)
                    abort = False
                    while True:
                        result = cursor.fetchone()
                        if result is None:
                            break
                        else:
                            (
                                db_id,
                                event_id,
                                channel_id,
                                experiment_id,
                                data_format,
                                samplerate,
                                padding_before,
                                padding_after,
                                raw_data,
                                filtered_data,
                                fit_data,
                            ) = result
                            try:
                                abort = (
                                    yield int(db_id),
                                    int(experiment_id),
                                    int(channel_id),
                                    int(event_id),
                                    float(samplerate),
                                    int(padding_before),
                                    int(padding_after),
                                    cast(
                                        npt.NDArray[np.float64],
                                        np.frombuffer(raw_data, dtype=data_format),
                                    ),
                                    cast(
                                        npt.NDArray[np.float64],
                                        np.frombuffer(filtered_data, dtype=data_format),
                                    ),
                                    cast(
                                        npt.NDArray[np.float64],
                                        np.frombuffer(fit_data, dtype=data_format),
                                    ),
                                )
                            except Exception:
                                self.logger.info(
                                    "Unable to interpret event data for event {event_id} in channel {channel_id} from experiment {experiment_id}"
                                )
                                continue
                            abort = bool(abort)
                            if abort is True:
                                break
                    if abort is True:
                        self.logger.info("Generator aborted")
                        return
        except sqlite3.Error as e:
            self.logger.warning(f"Database error executing query {query}: {e}")
            return
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def _finalize_initialization(self):
        """
        Apply the provided paramters and intialize any internal structures needed
        Should Raise if initialization fails.

        This function is called at the end of the class constructor to perform additional initialization specific to the algorithm being implemented.
        kwargs provided to the base class constructor are available as class attributes.
        """
        # this plugin opens and closes connections on the fly to avoid leaving resources open between calls
        self.db_path = Path(self.settings["Input File"]["Value"])

        conn = None
        cursor = None
        expected_tables = [
            "events",
            "channels",
            "experiments",
            "data",
            "sublevels",
            "columns",
        ]
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()

            query = "SELECT name FROM sqlite_master WHERE type='table';"
            cursor.execute(query)

            # Fetch all tables from the database
            existing_tables = [row[0] for row in cursor.fetchall()]

            if "sqlite_sequence" in existing_tables:
                existing_tables.remove("sqlite_sequence")

            # Check if the existing tables match the expected channels
            missing_tables = [
                table for table in expected_tables if table not in existing_tables
            ]
            extra_tables = [
                table for table in existing_tables if table not in expected_tables
            ]

            if missing_tables:
                raise ValueError(
                    f"Missing tables: {', '.join(missing_tables)}. Double check that you are loading a database of fitted metadata."
                )

            if extra_tables:
                raise ValueError(
                    f"Extra tables found: {', '.join(extra_tables)}. Double check that you are loading a database of fitted metadata."
                )

            # If there are no issues, log success
            self.logger.info("Database schema is valid.")

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in _finalize_initialization: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in _finalize_initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(
                f"Unexpected error in _finalize_initialization: {e}", exc_info=True
            )
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    # private API continued, should implemented by subclasses, but has default behavior if it is not needed

    # Utility functions, specific to subclasses as needed
    @log(logger=logger)
    def _get_sqlite_type(self, dtype: np.dtype) -> str:
        """
        Maps pandas dtype to SQLite data type.

        :param dtype: The pandas dtype
        :type dtype: str

        :return: The corresponding SQLite data type as a string.
        :rtype: str
        """
        if pd.api.types.is_integer_dtype(dtype):
            return "INTEGER"
        elif pd.api.types.is_float_dtype(dtype):
            return "REAL"
        elif pd.api.types.is_string_dtype(dtype) or pd.api.types.is_object_dtype(dtype):
            return "TEXT"
        elif pd.api.types.is_bool_dtype(dtype):
            return "INTEGER"  # Store booleans as 0 or 1
        elif pd.api.types.is_datetime64_any_dtype(dtype):
            return "TEXT"  # Store datetimes as ISO 8601 strings
        else:
            return "TEXT"  # Default for other or unknown types
