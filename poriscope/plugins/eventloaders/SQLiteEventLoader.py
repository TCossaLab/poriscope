# MIT License
#
# Copyright (c) 2025 TCossaLab
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# Contributors:
# Kyle Briggs

import logging
import sqlite3
from pathlib import Path
from typing import List

import numpy as np
from typing_extensions import override

from poriscope.utils.DocstringDecorator import inherit_docstrings
from poriscope.utils.LogDecorator import log
from poriscope.utils.MetaEventLoader import MetaEventLoader


@inherit_docstrings
class SQLiteEventLoader(MetaEventLoader):
    """
    Subclass of MetaEventLoader for loading event data from SQLite databases.

    This class provides methods to extract, filter, and stream event data stored in
    SQLite databases generated by Poriscope. It supports efficient querying and
    generator-based iteration over large event datasets.
    """

    logger = logging.getLogger(__name__)

    # Public API, probably usable as-is in most cases
    @log(logger=logger)
    @override
    def close_resources(self, channel=None):
        """
        Perform any actions necessary to gracefully close resources before app exit
        """
        pass

    @log(logger=logger)
    @override
    def reset_channel(self, channel=None):
        """
        Perform any actions necessary to gracefully close resources before app exit
        """
        pass

    @log(logger=logger)
    @override
    def _init(self) -> None:
        """
        **Purpose:** Perform generic class construction operations.

        All data plugins have this function and must provide an implementation. This is called immediately at the start of class creation and is used to do whatever is required to set up your reader. Note that no app settings are available when this is called, so this function should be used only for generic class construction operations. Most readers simply ``pass`` this function.
        """
        pass

    # private API, MUST be implemented by subclasses
    @log(logger=logger)
    @override
    def load_event(self, channel, index, data_filter=None):
        """
        :param channel: channel number from which to load data.
        :type channel: int
        :param index: The unique identifier for the event to load
        :type index: int

        :return: data and context corresponding to the event, with baseline padding before and after
        :rtype: Dict[str, Union[npt.NDArray[np.float64], int, float]]

        **Purpose:** Load the data and metadata associated with a single specified event

        Return the data and context for the event identified by index, optionally first applying a filter or preprofessing function to the data returned. You are responsible for raising an appropriate error if the index provided is invalid. The data must be returned as a dict with at least the following keys:

        .. code-block:: python

           event = {
                    'data': npt.NDArray[np.float64],  # the data in pA
                    'absolute_start': int,             # the start index of the event relative to the start of the experiment
                    'padding_before': int,            # number of data points in event['data'] before the event start estimate
                    'padding_after': int,             # number of data points in event['data'] after the event end estimate
                    'baseline_mean': float,           # local baseline mean value in pA - can be estimated from the padding if need be
                    'baseline_std': float             # local baseline standard deviation in pA - can be estimated from the padding if need be
                }

        """

        conn = None
        cursor = None
        event_data = {}
        query = None
        try:
            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = """SELECT e.absolute_start, e.padding_before, e.padding_after, e.baseline_mean, e.baseline_std, e.raw_data, ch.data_format
                       FROM events e
                       JOIN channels ch on e.channel_db_id = ch.id
                       WHERE e.channel_id = ? and event_id = ?;"""
            cursor.execute(query, (channel, index))

            event_row = cursor.fetchone()
            if event_row is None:
                raise IndexError(
                    f"No event with index {index} found for channel {channel}"
                )
            (
                absolute_start,
                padding_before,
                padding_after,
                baseline_mean,
                baseline_std,
                data,
                data_format,
            ) = event_row
            data = np.frombuffer(data, dtype=data_format)
            if data_filter is not None:
                data = data_filter(data)
            event_data = {
                "data": data,
                "absolute_start": absolute_start,
                "padding_before": padding_before,
                "padding_after": padding_after,
                "baseline_mean": baseline_mean,
                "baseline_std": baseline_std,
            }
            return event_data

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in load_event: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in load_event: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error in load_event: {e}", exc_info=True)
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_num_events(self, channel):
        """
        get the number of events available in the given channel

        :param channel: the channel to consider
        :type channel: int

        :return: The number of events in the channel for the given experiment
        :rtype: int
        """
        conn = None
        cursor = None
        num_events = 0  # Initialize to a default value
        try:
            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = """SELECT COUNT(*)
                       FROM events e
                       JOIN channels ch on e.channel_db_id = ch.id
                       WHERE e.channel_id = ?;"""
            cursor.execute(query, (channel,))

            num_events_row = cursor.fetchone()
            if num_events_row is None:
                raise ValueError(f"No events found for channel {channel}")
            num_events = num_events_row[0]

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in get_num_events: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in get_num_events: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error in get_num_events: {e}", exc_info=True)
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
        return num_events

    @log(logger=logger)
    @override
    def get_samplerate(self, channel):
        """
        Return the sampling rate for the channel.

        :param channel: the channel to consider
        :type channel: int

        :return: Sampling rate for the dataset.
        :rtype: float
        """
        conn = None
        cursor = None
        samplerate = 1  # Initialize to a default value
        try:

            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = """SELECT samplerate
                       FROM channels ch
                       WHERE ch.channel_id = ?;"""
            cursor.execute(query, (channel,))

            samplerate_row = cursor.fetchone()
            if samplerate_row is None:
                raise ValueError(f"No samplerate found for channel {channel}")
            samplerate = samplerate_row[0]

        except (sqlite3.Error, ValueError, Exception) as e:
            self.logger.error(f"SQLite error in get_samplerate: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in get_samplerate: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error in get_samplerate: {e}", exc_info=True)
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
        return samplerate

    @log(logger=logger)
    @override
    def get_valid_indices(self, channel: int) -> List[int]:
        """
        :param channel: channel number from which to load data.
        :type channel: int

        :return: A list of event ids
        :rtype: List[int]

        :raises: ValueError if no event_ids exist

        **Purpose** Return a list of indices correspond to the id of events within the given channel, or a list of all valid indices in the database if channel is not specified
        """
        conn = None
        cursor = None
        try:
            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = """SELECT event_id
                       FROM events e
                       WHERE channel_id = ?;"""
            cursor.execute(query, (channel,))
            event_rows = cursor.fetchall()
            event_ids = [
                row[0] for row in event_rows
            ]  # Extract the channel_id from each row
            if not event_ids:
                raise ValueError("No event_ids found.")
            return event_ids
        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in get_event_generator: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in get_event_generator: {e}")
            raise
        except Exception as e:
            self.logger.error(
                f"Unexpected error in get_event_generator: {e}", exc_info=True
            )
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()

    @log(logger=logger)
    @override
    def get_channels(self):
        """
        Return the keys of valid channels in the reader

        :return: keys of valid channels in the reader
        :rtype: List[int]
        """
        conn = None
        cursor = None
        channels = []  # Initialize to a default value
        try:
            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = """SELECT channel_id
                       FROM channels ch;"""
            cursor.execute(query)

            channel_rows = cursor.fetchall()
            channels = [
                row[0] for row in channel_rows
            ]  # Extract the channel_id from each row
            if not channels:
                raise ValueError("No channels found.")
            channels.sort()  # sort the channels

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in get_channels: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in get_channels: {e}")
            raise
        except Exception as e:
            self.logger.error(f"Unexpected error in get_channels: {e}", exc_info=True)
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
        return channels

    @log(logger=logger)
    @override
    def get_empty_settings(self, globally_available_plugins=None, standalone=False):
        """
        :param globally_available_plugins: a dict containing all data plugins that exist to date, keyed by metaclass. Must include "MetaReader" as a key, with explicitly set Type MetaReader.
        :type globally_available_plugins: Optional[ Dict[str, List[str]]]
        :param standalone: False if this is called as part of a GUI, True otherwise. Default False
        :type standalone: bool
        :return: the dict that must be filled in to initialize the filter
        :rtype: Dict[str, Dict[str, Any]]

        **Purpose:** Provide a list of settings details to users to assist in instantiating an instance of your :ref:`MetaWriter` subclass.

        Get a dict populated with keys needed to initialize the filter if they are not set yet.
        This dict must have the following structure, but Min, Max, and Options can be skipped or explicitly set to None if they are not used.
        Value and Type are required. All values provided must be consistent with Type.

        .. code-block:: python

           settings = {'Parameter 1': {'Type': <int, float, str, bool>,
                                           'Value': <value> or None,
                                           'Options': [<option_1>, <option_2>, ... ] or None,
                                           'Min': <min_value> or None,
                                           'Max': <max_value> or None
                                          },
                          ...
                          }

        Several parameter keywords are reserved: these are

        'Input File'
        'Output File'
        'Folder'

        These must have Type str and will cause the GUI to generate widgets to allow selection of these elements when used

        This function must implement returning of a dictionary of settings required to initialize the filter, in the specified format. Values in this dictionary can be accessed downstream through the ``self.settings`` class variable. This structure is a nested dictionary that supplies both values and a variety of information about those values, used by poriscope to perform sanity and consistency checking at instantiation.

        While this function is technically not abstract in :ref:`MetaEventLoader`, which already has an implementation of this function that ensures that settings will have the required ``Input File`` key available to users, in most cases you will need to override it to add any other settings required by your subclass or to specify which files types are allowed. If you need additional settings, which you almost certainly do, you **MUST** call ``super().get_empty_settings(globally_available_plugins, standalone)`` **before** any additional code that you add. For example, your implementation could look like this, to limit it to sqlite files:

        .. code:: python

            settings = super().get_empty_settings(globally_available_plugins, standalone)
            settings["Input File"]["Options"] = [
                                    "SQLite3 Files (*.sqlite3)",
                                    "Database Files (*.db)",
                                    "SQLite Files (*.sqlite)",
                                    ]
            return settings

        which will ensure that your have the ``Input File`` key and limit visible options to sqlite3 files. By default, it will accept any file type as output, hence the specification of the ``Options`` key for the relevant plugin in the example above.
        """
        settings = super().get_empty_settings(globally_available_plugins, standalone)
        settings["Input File"]["Options"] = [
            "SQLite3 Files (*.sqlite3)",
            "Database Files (*.db)",
            "SQLite Files (*.sqlite)",
        ]
        return settings

    @log(logger=logger)
    @override
    def _validate_settings(self, settings: dict) -> None:
        """
        Validate that the settings dict contains the correct information for use by the subclass.

        :param settings: Parameters for event detection.
        :type settings: dict
        :raises ValueError: If the settings dict does not contain the correct information.
        """
        if "Input File" not in settings.keys():
            raise KeyError("""settings must include an 'Input File' key""")

    @log(logger=logger)
    @override
    def _finalize_initialization(self) -> None:
        """
        Apply the provided paramters and intialize any internal structures needed
        Should Raise if initialization fails

        This function is called at the end of the class constructor to perform additional initialization specific to the algorithm being implemented.
        kwargs provided to the base class constructor are available as class attributes.
        """
        super()._finalize_initialization()
        conn = None
        cursor = None
        expected_tables = ["events", "channels", "columns"]
        try:
            conn = sqlite3.connect(Path(self.settings["Input File"]["Value"]))
            cursor = conn.cursor()

            query = "SELECT name FROM sqlite_master WHERE type='table';"
            cursor.execute(query)

            # Fetch all tables from the database
            existing_tables = [row[0] for row in cursor.fetchall()]

            # Check if the existing tables match the expected channels
            missing_tables = [
                table for table in expected_tables if table not in existing_tables
            ]
            extra_tables = [
                table for table in existing_tables if table not in expected_tables
            ]

            if "sqlite_sequence" in existing_tables:
                existing_tables.remove("sqlite_sequence")

            if missing_tables:
                raise ValueError(
                    f"Missing tables: {', '.join(missing_tables)}. Double check that you are loading a database of raw event data."
                )

            if extra_tables and not (
                len(extra_tables) == 1 and extra_tables[0] == "sqlite_sequence"
            ):
                raise ValueError(
                    f"Extra tables found: {', '.join(extra_tables)}. Double check that you are loading a database of raw event data."
                )

            # If there are no issues, log success
            self.logger.info("Database schema is valid.")

        except sqlite3.Error as e:
            self.logger.error(f"SQLite error in _finalize_initialization: {e}")
            raise  # Re-raise the exception to propagate it
        except ValueError as e:
            self.logger.error(f"Value error in _finalize_initialization: {e}")
            raise
        except Exception as e:
            self.logger.error(
                f"Unexpected error in _finalize_initialization: {e}", exc_info=True
            )
            raise
        finally:
            if cursor:
                cursor.close()
            if conn:
                conn.close()
